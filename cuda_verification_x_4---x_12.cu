#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <cuda_runtime.h>


typedef unsigned long long 	uint64_t;
typedef unsigned int 		uint32_t;



// constants for craft
#define ROUND_NUM 8


#define KEY0 0xb36cab650838eb24LLU
#define KEY1 0xe5c67f9611b68427LLU


#define INPUT_DIFF 0x00000000005a0a00LLU
#define COND 0x00000000005a0a00LLU




// constants for gpu
#define ENUM_NUM 22
#define BLOCK_NUM 128 //2^7
#define THREAD_NUM 128 // 2^7
#define THREADS_SHIFT 14 // (7+7)



#define ONE (0x1LLU)
#define MASK16 (0xfLLU)






// the output of g
#define LFSR(g) (((g >> 39) ^ (g >> 34) ^ (g >> 24) ^ (g >> 19) ^ (g >> 14) ^ (g >> 5)) & ONE)


#define LEFTROTBY4(w, shift) ((w) << ((shift) << 2))
#define GETBY4(w, p) (((w) >> ((p) << 2)) & 0xfLLU)

#define FROM_I_TO_J(w, i, j) (LEFTROTBY4(GETBY4(w, i), j))
#define Sbox_FROM_I_TO_J(w, i, j) (LEFTROTBY4(S[GETBY4(w, i)], j))

/* Cell Shuffle in the tk schedule */
// const int Q[16] =
// {0xc, 0xa, 0xf, 0x5, 0xe, 0x8, 0x9, 0x2, 0xb, 0x3, 0x7, 0x4, 0x6, 0x0, 0x1, 0xd};
#define Q(T) (FROM_I_TO_J(T, 12, 0) ^ FROM_I_TO_J(T, 10, 1) ^ FROM_I_TO_J(T, 15, 2) ^ FROM_I_TO_J(T, 5, 3) ^ FROM_I_TO_J(T, 14, 4) ^ FROM_I_TO_J(T, 8, 5) ^ FROM_I_TO_J(T, 9, 6) ^ FROM_I_TO_J(T, 2, 7) ^ FROM_I_TO_J(T, 11, 8) ^ FROM_I_TO_J(T, 3, 9) ^ FROM_I_TO_J(T, 7, 10) ^ FROM_I_TO_J(T, 4, 11) ^ FROM_I_TO_J(T, 6, 12) ^ FROM_I_TO_J(T, 0, 13) ^ FROM_I_TO_J(T, 1, 14) ^ FROM_I_TO_J(T, 13, 15))

/* Cell Shuffle in the linear layer */
// const int P[16] =
// {0xf, 0xc, 0xd, 0xe, 0xa, 0x9, 0x8, 0xb, 0x6, 0x5, 0x4, 0x7, 0x1, 0x2, 0x3, 0x0};

/* S-box */
// const int S[16] =
// {0xc, 0xa, 0xd, 0x3, 0xe, 0xb, 0xf, 0x7, 0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6};


#define PS(st) (Sbox_FROM_I_TO_J(st, 15, 0) ^ Sbox_FROM_I_TO_J(st, 12, 1) ^ Sbox_FROM_I_TO_J(st, 13, 2) ^ Sbox_FROM_I_TO_J(st, 14, 3) ^ Sbox_FROM_I_TO_J(st, 10, 4) ^ Sbox_FROM_I_TO_J(st, 9, 5) ^ Sbox_FROM_I_TO_J(st, 8, 6) ^ Sbox_FROM_I_TO_J(st, 11, 7) ^ Sbox_FROM_I_TO_J(st, 6, 8) ^ Sbox_FROM_I_TO_J(st, 5, 9) ^ Sbox_FROM_I_TO_J(st, 4, 10) ^ Sbox_FROM_I_TO_J(st, 7, 11) ^ Sbox_FROM_I_TO_J(st, 1, 12) ^ Sbox_FROM_I_TO_J(st, 2, 13) ^ Sbox_FROM_I_TO_J(st, 3, 14) ^ Sbox_FROM_I_TO_J(st, 0, 15))


/* Round constants generated by 3-bit LFSR, XOR-ed at state[5] */
// const int RC3[32] =
// {0x1, 0x4, 0x2, 0x5, 0x6, 0x7, 0x3, 0x1, 0x4, 0x2, 0x5, 0x6, 0x7, 0x3, 0x1, 0x4,
//  0x2, 0x5, 0x6, 0x7, 0x3, 0x1, 0x4, 0x2, 0x5, 0x6, 0x7, 0x3, 0x1, 0x4, 0x2, 0x5};

//  Round constants generated by 4-bit LFSR, XOR-ed at state[4] 
// const int RC4 [32] =
// {0x1, 0x8, 0x4, 0x2, 0x9, 0xc, 0x6, 0xb, 0x5, 0xa, 0xd, 0xe, 0xf, 0x7, 0x3, 0x1,
//  0x8, 0x4, 0x2, 0x9, 0xc, 0x6, 0xb, 0x5, 0xa, 0xd, 0xe, 0xf, 0x7, 0x3, 0x1, 0x8};


__device__ __constant__ uint64_t 
S[16] = {0xc, 0xa, 0xd, 0x3, 0xe, 0xb, 0xf, 0x7, 0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6};

__device__ __constant__ uint64_t 
RC[32] = {0x110000, 0x480000, 0x240000, 0x520000, 0x690000, 0x7c0000, 0x360000, 0x1b0000, 
 		0x450000, 0x2a0000, 0x5d0000, 0x6e0000, 0x7f0000, 0x370000, 0x130000, 0x410000,
 		0x280000, 0x540000, 0x620000, 0x790000, 0x3c0000, 0x160000, 0x4b0000, 0x250000, 
 		0x5a0000, 0x6d0000, 0x7e0000, 0x3f0000, 0x170000, 0x430000, 0x210000, 0x580000};



// requirements
// tweak[7] == key1[10]
// tweak[10] == key1[10]

// tweak[0] == key1[13]
// tweak[13] == key1[13]
    
// tweak[3] == key1[9]
// tweak[9] == key1[9]
        
// set values in tweak to 0.
__device__ __constant__ uint64_t 
tweak_mask = ((~0x0LLU) ^ LEFTROTBY4(MASK16, 3) ^ LEFTROTBY4(MASK16, 9) ^ LEFTROTBY4(MASK16, 0) ^ LEFTROTBY4(MASK16, 13) ^ LEFTROTBY4(MASK16, 7) ^ LEFTROTBY4(MASK16, 10));

// prepare values in tweak to be set.
__device__ __constant__ uint64_t 
key1_setto_tweak = (LEFTROTBY4(GETBY4(KEY1, 9), 3) | LEFTROTBY4(GETBY4(KEY1, 9), 9) | LEFTROTBY4(GETBY4(KEY1, 13), 0) | LEFTROTBY4(GETBY4(KEY1, 13), 13) | LEFTROTBY4(GETBY4(KEY1, 10), 7) | LEFTROTBY4(GETBY4(KEY1, 10), 10));










__device__ static __forceinline__ uint64_t 
round(const uint64_t old_st, const uint64_t tk0, const uint64_t tk1, const uint64_t tk2, const uint64_t tk3, const int r) {

    /* MC */
    uint64_t row3 = (old_st >> 48);
    uint64_t st = old_st ^ ((old_st >> 32) & 0xffff) ^ row3 ^ (row3 << 16);

    /* Add constants */
    st ^= RC[r];

    /* Add tweakey */
    switch (r % 4) {
        case 0:
            st ^= tk0;
            break;
        case 1:
            st ^= tk1;
            break;
        case 2:
            st ^= tk2;
            break;
        case 3:
            st ^= tk3;
            break;
    }

    /* PN and SB */
    return PS(st);
}






__global__ void 
test_correct_pairs(const uint64_t *d_init_values, uint32_t *d_correct_num) {

	// recieve input data
	const uint64_t cur_idx = blockDim.x * blockIdx.x + threadIdx.x;
	uint64_t p0_lfsr = d_init_values[cur_idx * 2];
	uint64_t tweak_lfsr = d_init_values[cur_idx * 2 + 1];
	uint32_t counter_for_correct_pairs = 0;

	uint64_t p0, p1, tweak;
	uint64_t tk0, tk1, tk2, tk3, qt;


	// main loop in each device
	for (uint64_t data_i = 0; data_i < (ONE << ENUM_NUM); data_i++) {

		// plain p0 is from LFSR g(U) = u0+u5+u15+u20+u25+u34.
		if (LFSR(p0_lfsr) == 0) {
			p0_lfsr = (p0_lfsr << 1);
		} else {
			p0_lfsr = ((p0_lfsr << 1) ^ ONE);
		}
		p0 = p0_lfsr;

		// plain p1
		p1 = p0 ^ INPUT_DIFF;


		// tweak is also from LFSR g(U) = u0+u5+u15+u20+u25+u34.
		if (LFSR(tweak_lfsr) == 0) {
			tweak_lfsr = (tweak_lfsr << 1);
		} else {
			tweak_lfsr = ((tweak_lfsr << 1) ^ ONE);
		}

		// set hypotheses
		tweak = ((tweak_lfsr & tweak_mask) | key1_setto_tweak);


		// initialize key
		tk0 = KEY0 ^ tweak;
		tk1 = KEY1 ^ tweak;
		qt = Q(tweak);
		tk2 = KEY0 ^ qt;
		tk3 = KEY1 ^ qt;

		// foward
		for (int r = 0; r < ROUND_NUM; r++) {
            p0 = round(p0, tk0, tk1, tk2, tk3, r);
            p1 = round(p1, tk0, tk1, tk2, tk3, r);
        }   


        // test correct pairs
        if ((p0 ^ p1) == COND) {
        	// printf("p0: %lx, c0: %lx, tweak: %lx\n", p0_lfsr, p0, tweak);
        	// printf("p1: %lx, c1: %lx\n\n", p0_lfsr ^ INPUT_DIFF, p1);
            counter_for_correct_pairs++;
        }
	}

	d_correct_num[cur_idx] = counter_for_correct_pairs;
}




static inline void print_word(uint64_t w) {

	printf("0x");
	for (int i = 15; i >= 0; i--) {

		if (i < 15 && (i & 0x3) == 0x3) {
			printf(" ");
		}

		printf("%llx", (w >> (i << 2)) & 0xfLLU);
	}
}




int main(int argc, char** argv) {


	// parsing inputs
	// argv[1]: gpu device number; argv[2]: seed for random number.

	int dev_id, seed;

	if (argc >= 3) {
		dev_id = atoi(argv[1]);
		seed = atoi(argv[2]);

	} else {
		dev_id = 3;
		seed = time(0);
	}	

	cudaSetDevice(dev_id);
	srand(seed);

	printf("finish setting device %d with seed %d\n\n", dev_id, seed);



	// generate initial states for each threads.
	const uint64_t thr_num = BLOCK_NUM * THREAD_NUM;
	uint64_t h_init_values[2 * thr_num];

	for (uint64_t i = 0; i < 2 * thr_num; i++) {		
		h_init_values[i] = rand();
	 	uint64_t temp = rand();
		h_init_values[i] ^= (temp << 32);
	}



	printf("finish initializing random values!\n");






	// allocate memory.
	cudaError_t err = cudaSuccess;	

	uint64_t *d_init_values = NULL;
	err = cudaMalloc((void **) &d_init_values, 2 * thr_num * sizeof(uint64_t));
	if (err != cudaSuccess) {
		fprintf(stderr, "Failed to allocate initial values (error code %s)!\n", cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}

	err = cudaMemcpy(d_init_values, h_init_values, 2 * thr_num * sizeof(uint64_t), cudaMemcpyHostToDevice);
	if (err != cudaSuccess) {
		fprintf(stderr, "Failed to copy init_values from host to device (error code %s)!\n", cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}


	uint32_t *d_correct_num = NULL;
	err = cudaMalloc((void **) &d_correct_num, thr_num * sizeof(uint32_t));
	if (err != cudaSuccess) {
		printf("Failed to allocate correct_num (error code %s)!\n", cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}


	printf("finish allocating memory!\n");








	// test for correct pairs.
	printf("enum num (on each device): %d\ntotal thread num: %d (block num %d * thread num %d)\n", ENUM_NUM, BLOCK_NUM * THREAD_NUM, BLOCK_NUM, THREAD_NUM);

	
	// real start
	cudaEvent_t start1;
	cudaEventCreate(&start1);
	cudaEvent_t stop1;
	cudaEventCreate(&stop1);
	cudaEventRecord(start1, NULL);

	printf("begin testing correct pairs!\n\n");

	printf("\ndata num : 2 ^ %d\n", ENUM_NUM + THREADS_SHIFT);
	printf("Round : %d\n", ROUND_NUM);
	printf("key0 : ");
	print_word(KEY0);
	printf("\nkey1 : ");
	print_word(KEY1);
	printf("\ndiff at key0[9] : %llx\n", GETBY4(KEY0, 9) ^ GETBY4(KEY1, 9));
	printf("input diff : ");
	print_word(INPUT_DIFF);	
	printf("\noutput diff : ");
	print_word(COND);
	printf("\n");



	test_correct_pairs<<<BLOCK_NUM, THREAD_NUM>>>(d_init_values, d_correct_num);


	cudaEventRecord(stop1, NULL);
	cudaEventSynchronize(stop1);
	float msecTotal1 = 0.0f;
	cudaEventElapsedTime(&msecTotal1, start1, stop1);
	err = cudaGetLastError();

	if (err != cudaSuccess) {
		fprintf(stderr, "Failed to launch test_correct_pairs kernel (error code %s)!\n", cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}


	uint32_t h_correct_num[thr_num];

	err = cudaMemcpy(h_correct_num, d_correct_num, thr_num * sizeof(uint32_t), cudaMemcpyDeviceToHost);
	if (err != cudaSuccess) {
		fprintf(stderr, "Failed to copy correct numbers from device to host (error code %s)!\n", cudaGetErrorString(err));
		exit(EXIT_FAILURE);
	}


	printf("computation is done!\n");




	// get probability.
	uint64_t all_num = 0;
	for (uint64_t i = 0; i < thr_num; i++) {
		all_num += h_correct_num[i];
	}


	printf("\n\nright pairs : %llu\n", all_num);
	printf("pro : %f\n\n", log2(float(all_num)/float(uint64_t(1) << (ENUM_NUM + THREADS_SHIFT))));



	printf("\ntime:%.3lf sec.\n---------------------------------------\n", msecTotal1 / 1000.0);

	cudaFree(d_init_values);
	cudaFree(d_correct_num);

}
